import { store, BigInt, Address, JSONValue, Value, ipfs } from '@graphprotocol/graph-ts'

// This is just an example event type generated by `graph-cli`
// from an Ethereum smart contract ABI
import { Payment, JackpotPayment, Commit } from './build/types/Dice2Win/Dice2Win'

// This is an example of an entity type generated from a
// subgraph's GraphQL schema
import { Beneficiary } from './build/types/schema'

const BENEFICIARY = 'Beneficiary'

// Update the winnings of the beneficiary with the given address. Create
// a new beneficiary if none exists yet
// Return that beneficiary, but do not store it yet
function updateWinnings(beneficiary: Address, amount: BigInt) : Beneficiary {
  let id = beneficiary.toHex()
  let ben = Beneficiary.load(id)
  if (ben === null) {
    ben = new Beneficiary(id)
    ben.winnings = amount
    // This initialization is important; otherwise we store NULLS
    // in new jackpots
    ben.jackpots = BigInt.fromI32(0)
  } else {
    ben.winnings = ben.winnings.plus(amount)
  }
  return ben as Beneficiary
}

export function handlePayment(event: Payment): void {
  let ben = updateWinnings(event.params.beneficiary, event.params.amount)
  store.set(BENEFICIARY, ben.id, ben)
}

export function handleJackpotPayment(event: JackpotPayment): void {
  let ben = updateWinnings(event.params.beneficiary, event.params.amount)

  ben.jackpots = ben.jackpots.plus(BigInt.fromI32(1))

  store.set(BENEFICIARY, ben.id, ben)
}

export function addName(data: JSONValue, generation: Value): void {
  // expect a map of the form { "id": "anId", "name": "aName" }
  let map = data.toObject();
  let id = map.get("id").toString();
  let name = map.get("name").toString();

  let ben = Beneficiary.load(id);
  if (ben != null) {
    ben.name = name;
    ben.generation = generation.toI32();
    ben.save();
  }
}

export function handleCommit(event: Commit): void {
  let file = "QmV5L2Z9J49UmdHT2EZk7BDX1GWDKnwkW9Sfy8RuChnc3q";
  ipfs.mapJSON(file, "addName", Value.fromI32(2))
}
